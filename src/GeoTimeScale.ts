import intervals from './GTS_2020.json'
import { partition, stratify, Selection, select, zoom as d3zoom, BaseType, transition, HierarchyNode } from 'd3';
import { d3ZoomEvent, GeoTimeScaleOptions, IntervalItem, NodeItem } from './typing';
import { getTextWidth } from './helpers';

const DefaultOpts: GeoTimeScaleOptions = {
  width: 960,
  height: 400,
  fontSize: 12,
  fontFamily: 'sans-serif',
  onChange: undefined,
  intervals: intervals,
  margin: {
    top: 0, right: 0, bottom: 0, left: 0,
  },
  padding: {
    top: 0, right: 0, bottom: 0, left: 0,
  },
  transition: 450,
  intervalSum: d => d.leaf ? d.start - d.end : 0,
  simplify: false,
  neighborWidth: 100,
  tickLength: 15
}

export default class GeoTimeLine {
  /** text font */
  readonly font: string;
  /** svg object */
  readonly svg: Selection<SVGSVGElement, unknown, HTMLElement, any>;
  /** interval data */
  readonly intervals: IntervalItem[];
  /** hierarchical data generated by intervals */
  readonly hierarchicalData: HierarchyNode<IntervalItem>;
  /** the root hierarchical data */
  readonly root: NodeItem;
  /** user input options */
  readonly options: GeoTimeScaleOptions
  private _onChange: (node: NodeItem) => void;
  private _ready: boolean;
  private _cellGroup: Selection<SVGGElement, unknown, HTMLElement, any>;
  private _cell: Selection<SVGGElement | BaseType, NodeItem, SVGGElement, unknown>;
  private _rect: Selection<SVGRectElement, NodeItem, SVGGElement, unknown>;
  private _text: Selection<SVGTextElement, NodeItem, SVGGElement, unknown>;
  private _ticks: Selection<SVGGElement, NodeItem, SVGGElement, unknown>;
  /** get or set animation transition time */
  transition: number;
  private _simplify: boolean;
  private _focus: NodeItem;
  private _sequence: NodeItem[];
  private _neighborWidth: number;
  private _tickLength: number;

  /**
   * Create a GeoTimeLine
   * @param selector CSS selector string
   * @param {number} [options.width] svg width, defaults to container's width
   * @param {number} [options.height = 400] svg height, defaults to 400px
   * @param {number} [options.fontSize = 12] font size, defaults to 12px
   * @param {string} [options.fontFamily = 'sans-serif'] font family, defaults to 'sans-serif'
   * @param {Function} [options.onChange] callback when focused node change
   * @param {IntervalItem[]} [options.intervals] geo time intervals array
   * @param {Object} [options.margin] svg margin, defaults to { top: 0, right: 0, bottom: 0, left: 0 }
   * @param {Object} [options.padding] svg padding, defaults to { top: 0, right: 0, bottom: 0, left: 0 }
   * @param {number} [options.transition = 450] animation time, defaults to 450ms
   * @param {Function} [options.intervalSum] interval transform setting, defaults to d => d.leaf ? d.start - d.end : 0
   * @param {boolean} [options.simplify = true] show all levels or not, defaults to false
   * @param {number} [options.neighborWidth = 100] focused node's neighbor node width, defaults to 100px
   * @param {number} [options.tickLength = 15] tick length, defaults to 15px
   */
  constructor(selector: string, options: GeoTimeScaleOptions = {}) {
    const opts: GeoTimeScaleOptions = {
      ...DefaultOpts,
      margin: {
        ...DefaultOpts.margin,
        ...options.margin
      },
      padding: {
        ...DefaultOpts.padding,
        ...options.padding
      },
      width: +select(selector).style('width').split('px')[0],
      ...options
    }
    const { width, height, intervalSum, onChange, transition, simplify, neighborWidth, tickLength } = opts
    this.transition = transition
    this._onChange = onChange
    this.font = `${opts.fontSize}px ${opts.fontFamily}`
    this.intervals = opts.intervals
    this._simplify = simplify
    this._neighborWidth = neighborWidth
    this._tickLength = tickLength

    this.options = opts
    
    this.hierarchicalData = stratify<IntervalItem>()(intervals).sum(intervalSum)

    this.root = partition<IntervalItem>()
      .size([width, (height - opts.margin.bottom - opts.margin.top) * (simplify ? this.hierarchicalData.height / 2 : 1)])
      .padding(0)(this.hierarchicalData)
      
    this.root.each(d => {
      d.target = {
        x0: d.x0,
        x1: d.x1
      }
      d.visible = true
    })
    this._sequence = []

    this.svg = select(selector)
      .append("svg")
      .attr("viewBox", [0, 0, width, height])
      .style("font", this.font)

    this._ready = false

    this._init()
  }

  /** get or set focused stage
   * @example
   * geoTimeScale.stage = 'Cambrian'
   */
  get stage(): string {
    return this._focus.data.name
  }

  set stage(val: string) {
    const node = this.root.find(node => node.data.name === val)
    if (node) {
      this._clicked(undefined, node)
    }
  }

  get sequence(): NodeItem[] {
    return this._sequence
  }

  private _init() {
    const self = this
    const svg = self.svg

    // draw cells
    self._cellGroup = svg
      .append("g")
      .attr("id", "cells")

    self._cell = self._cellGroup
      .selectAll("g")
      .data(self.root.descendants())
      .join("g")
      .attr("transform", (d) => `translate(0, ${d.y0})`)

    self._rect = self
      ._drawRect(self._cell)
      .on("click", self._clicked)

    self._addTitle(self._cell)

    // draw text
    self._text = self._drawText(self._cell)
    self._ticks = self._addTicks(self._cell)
    
    // zoom function
    function zoomed(e: d3ZoomEvent) {
      const event = e.sourceEvent

      if (event.type === 'wheel') {
        if ((event as any).wheelDelta < 0) {
          self._clicked(undefined, self._focus)
        } else {
          const { offsetX } = event
          const offsetY = event.offsetY + (self._simplify ? (self._focus?.y0 ?? 0) : 0)
          const node = self.root.find(node => node.target.x0 <= offsetX && node.target.x1 > offsetX && node.target.y0 <= offsetY && node.target.y1 > offsetY)
          if (node) {
            self._focus = null
            self._clicked(undefined, node)
          }
        }
      }
    }

    self._cellGroup
      .call(
        d3zoom()
          .on('zoom', zoomed)
          .on("end", () => {
            self._rect.attr("cursor", "pointer");
          })
      )
    
    self._clicked(undefined, self.root)
    
    svg.on("pointerleave", () => {
      this._cell.attr("fill-opacity", 1);
      this._sequence = [];
    });

    this._ready = true
  }

  private _dispatchFunc(func: typeof this._onChange) {
    if (func && this._ready) {
      func(this._focus)
    }
  }

  private _addTitle(cell: typeof this._cell) {
    return cell.append("title").text((d) => {
      const sequence = d
        .ancestors()
        .map((d) => d.data.name)
        .reverse();

      return `${sequence.join(" > ")}`;
    });
  }

  /**
   * draw rect
   */
  private _drawRect(cell: typeof this._cell) {
    return cell
      .append("rect")
      .attr("id", d => d.data.name)
      .attr('fill', d => d.data.color)
      .attr("stroke", "white")
      .attr("stroke-width", 0.5)
      .attr("cursor", "pointer")
      .on("pointerenter", (_event, d) => {
        // Get the ancestors of the current segment
        const sequence = d.ancestors().reverse();
        // Highlight the ancestors
        cell.attr("fill-opacity", (d) => (sequence.includes(d) ? 1.0 : 0.5));

        this._sequence = sequence;
      })
  }

  /** draw text */
  private _drawText(cell: typeof this._cell) {
    const text = cell
      .append("text")
      .style("user-select", "none")
      .attr("pointer-events", "none")
      .attr("fill", (d) => d.data.textColor ?? "black")
      .attr("opacity", 0.8)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
    
    return text
  }

  private _addTicks(cell: typeof this._cell) {
    const ticks = cell
      .append('g')
      .attr('id', 'tick')

    ticks
      .append("line")
      .attr("stroke", "#555")
      .attr("stroke-width", 1)
      .attr("x1", 0)
      .attr("y1", 0)
      .attr("x2", 0)
      .attr("y2", this._tickLength)
    
    ticks
      .append("text")
      .attr("x", 0)
      .attr("y", this._tickLength + this.options.fontSize / 2)
      .attr("font-size", (d) => `${1 - 0.05 * d.data.level}em`)
      .text((d) => d.data.start + 'ma')
      .attr("text-anchor", d => d.data.start === this.root.data.start ? 'start' : 'middle')
      .clone(true)
      .lower()
      .attr("stroke-linejoin", "round")
      .attr("stroke-width", 1)
      .attr("stroke", "white")
    
    return ticks
  }

  /**
   * click rect and zoom
   */
  private _clicked = (event: any, p: NodeItem): boolean => {
    const focus = p === this._focus ? (p?.parent ?? p) : p;
    this._focus = focus;

    const focusAncestors = focus.ancestors().slice(1); // Ignore clicked node itself
    const trans = event ? transition().duration(this.options.transition) : null; // Can't transition when using input, bit of a hack

    // Show a bit of the neighbouring cells on focus of an interval
    const leftNeighbor =
      focus.data.start === this.root.data.start ? 0 : this._neighborWidth;
    const rightNeighbor = focus.data.end === this.root.data.end ? 0 : this._neighborWidth;
    const widthMinusNeighbors = this.options.width - rightNeighbor - leftNeighbor;
    const focusWidth = focus.x1 - focus.x0; // partition width of focused node

    this.root.each(d => {
      d.target = {
        x0:
          leftNeighbor + ((d.x0 - focus.x0) / focusWidth) * widthMinusNeighbors,
        x1:
          leftNeighbor + ((d.x1 - focus.x0) / focusWidth) * widthMinusNeighbors,
        y0: d.y0,
        y1: d.y1,
      }
      if (this._simplify) {
        d.visible = [focus.depth, focus.depth + 1].includes(d.depth) || (!focus.children && d.depth === focus.depth - 1)
      }
    })

    this._rect
      .transition(trans)
      .attr('x', d => (d.target.x0))
      .attr('width', d => (d.target.x1 - d.target.x0))
      .attr("height", (d) => (d.visible ? (d.y1 - d.y0) : 0))
      .attr("stroke", "white")
      .attr("stroke-width", 1);

    this._text
      .transition(trans)
      .attr("fill-opacity", (d) =>
        focusAncestors.includes(d) ? 1 : +(d.x1 - d.x0 > 14)
      )
      .attr("x", (d) => {
        // Position all the ancestors labels in the middle
        if (focusAncestors.includes(d)) {
          return focus.target.x0 + (focus.target.x1 - focus.target.x0) / 2;
        }

        const textX = d.target.x0 + (d.target.x1 - d.target.x0) / 2;
        return Number.isNaN(textX) ? 0 : textX;
      })
      .attr("y", (d) => (d.y1 - d.y0) / 2)
      .attr("opacity", d => d.visible ? 1 : 0)
      .text((d) => {
        const rectWidth = Math.abs(d.target.x1 - d.target.x0);
        const labelWidth = getTextWidth(d.data.name, this.font);
        const abbrev = d.data.abbr || d.data.name.charAt(0);

        return rectWidth - 8 < labelWidth ? abbrev : d.data.name;
      })

    this._ticks
      .transition(trans)
      .attr("transform", (d) => `translate(${d.target.x0}, 0)`)
      .attr('opacity', d => {
        // unique start
        if (d.parent?.visible && d.data.start === d.parent.data.start) return 0
        const text = d.data.start + 'ma'
        const rectWidth = Math.abs(d.target.x1 - d.target.x0);
        const labelWidth = getTextWidth(text, this.font);

        return rectWidth < labelWidth * (1 - 0.05 * d.data.level) ? 0 : 1;
      })

    if (this._simplify) {
      this._cell
        .transition(trans)
        .style('opacity', d => d.visible ? 1 : 0)
  
      this._cellGroup
        .transition(trans)
        .attr("transform", `translate(0, ${!this._focus.children ? -(this._focus.parent?.y0 ?? 0) : -this._focus.target.y0})`)
    }

    this._rect
      .select(`#${focus.data.name}`)
      .transition(trans)
      .attr("stroke", "black")
      .attr("stroke-width", 1.5)
    
    this._dispatchFunc(this._onChange)

    return true
  }

}